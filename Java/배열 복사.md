#### 배열 복사

##### for문 사용

for(int i=0; i<oldntArray.length; i++){

​	newlntArray[i] = oldntArray[i];

}

##### System.arraycopy() 메소드 사용

System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);

src : 원본 배열, srcPos : 복사할 항목의 시작 인덱스

dest : 새 배열,  destPos: 붙여넣을 시작 인덱스  

length : 복사할 개수



```java
package ch_a2_Array.no1;

public class A{
	
	public static void main(String[] args) {
		String[] old1 = {"java", "array", "copy"};
		String[] new1 = new String[5];
		
		System.arraycopy(old1, 0, new1, 1, old1.length);
		
		for(int i=0; i<new1.length; i++) {
			System.out.println(new1[i]);
		}
	}
}
```





* 참조 타입 배열일 경우, 배열 복사가 되면 복사되는 값이 객체의 번지이므로 새 배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일하다.

  -> 이것을 얕은 복사라고 한다

* 깊은 복사는 참조하는 객체도 별도로 생성하는 것을 말한다



### 향상된 for 문

* 반복 실행을 하기 위해 카운터 변수와 증감식을 사용하지 않는다

* 배열 및 컬렉션 항목의 개수만큼 반복하고, 자동적으로 for문을 빠져나간다

  * 형식 for(타입 변수 : 배열){

    ​	실행문;

    }

    

### 열거 타입 선언

열거 타입 : 한정된 값만을 갖는 데이터 타입

* 열거 타입을 선언하기 위해서는 먼저 열거 타입 이름으로 소스 파일(.java)을 생성해야 한다

열거 타입 변수는 열거 상수를 저장할 수 있다.

* 열거 상수는 단독으로 사용할 수 없고 반드시 열거타입.열거상수로 사용된다

  ex) 열거타입 변수 = 열거타입.열거상수;

  -> Week today = Week.SUNDAY;

* 열거상수는 **객체이다**



### java.lang.Enum 클래스

* Enum 클래스에 선언된 메소드들이다
* 이 메소들은 열거 객체에서 사용가능하다
  * 이유는 모든 열거 타입은 컴파일 시에 Enum 클래스를 상속하게 되어 있기 때문

| 리턴 타입 | 메소드(매개 변수)    | 설명                                  |
| --------- | -------------------- | ------------------------------------- |
| String    | name()               | 열거 객체의 문자열을 리턴             |
| int       | ordlinal()           | 열거 객체의 순번(0부터 시작)          |
| int       | compareTo()          | 열거 객체를 비교해서 순번 차이를 리턴 |
| 열거 타입 | valueOf(String name) | 주어진 문자열의 열거 객체를 리턴      |
| 열거 배열 | values               | 모든 열거 객체들을 배열로 리턴        |



### 클래스

#### 객체지향 프로그래밍(OOP)

: 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씪 조립해서 완성된 프로그램을 만드는 기법 

#### 객체

: 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 **자신의 속성**을 가지고 있고, 다른 것과 **식별 가능**한 것

ex) 물리적 : 자동차, 책, 사람 / 추상적 : 학과, 강의, 교과

#### 객체는 속상과 동작으로 구성

* 속성 <-> 필드(field) 

  Ex) 이름, 나이

* 동작 <->메소드

#### 객체 모델링

: 현실 세계의 객체를 소프트웨어 객체로 설계하는 것

* 객체 모델링은 현실 세계 객체의 **속성과 동작**을 추려내어 소프트웨어 객체의 **필드와 메소드**로 정의하는 과정

#### 객체의 상호작용

* 객체들 사이의 상호작용(데이터를 주고 받는) 수단은 메소드

  > 도트 연산자 (.)는 객체의 필드와 메소드에 접근할 떄 사용. 매개값은 메소드를 실행하기 위해 필요한 데이터다 

#### 객체 간의 관계

* **집합 관계**에 있는 객체는 하나는 부품이고 하나는 완성품

  Ex) 부품(엔진, 타이어) <- 집합관계 -> 완성품(자동차)

* 사용 관계는 객체 간의 상호작용을 말한다. (객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다)

  Ex) 사람 -> 사용관계 -> 자동차

* 상속 관계는 상위(부모)객체를 기반으로 하위(자식)객체를 생성하는 관계를 말한다

  Ex) 기계 <- 상속관계 -> 자동차 

#### 객체 지향 프로그램의 특징

1. 캡슐화

   : 실제 구현 내용을 감추는 것

   	+ 외부 객체는 객체내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용
   	+ 보호하는 이유 : 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다
   	+ 노출시킬 것인지, 숨길 것인지 -> 접근 제한자 사용

2. 상속

   : 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계(반복된 코드의 중복을 줄여준다)

3. 다형성(너무너무너무너무중요하다~)

   : 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질 (**하나의 타입에 여러 객체를 대입함**으로써 다양한 기능을 이용할 수 있도록 해준다)

* 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다

  (부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.)

* 다형성의 효과로 객체는 부품화가 가능하다 

  Ex) 타이어 인터페이스 타입 적용 -> 이 인터페이스를 구현한 실제 타이어들은 어떤 것이든 상관없이 장착(대입) 가능 

#### 객체와 래스

* 클래수로부터 만들어진 객체를 해당 클래스의 **인스턴스**라고한다

  Ex) 자동차 객체는 자동차 클래스의 인스턴스이다

* 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다

#### 클래스 선언

* 사용하고자 하는 객체를 구상했다면, 그 객체의 대표 이름을 하나 결정하고 이것을 **클래스 이름**으로 한다
* 클래스 이름(다른 클래스와 식별할 목적으로 사용)
  * 작성 규칙
    1. 하나 이상의 문자로 이루어져야 한다
    2. 첫번째 글자는 숫자가 올 수 없다
    3. $, _외의 특수 문자는 사용할 수 없다
    4. 자바 키워드는 사용할 수 없다 

* 클래스 이름을 정했다면 ""클래스이름.java"로 소스 파일을 생성

* 소스 파일당 하나의 클래스를 선언한다(<-일반적)

  but, 두개 이상의 클래스 선언도 가능하다

* **소스파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다**

* 두 개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일(.class)은 클래스를 선언한 개수만큼 생긴다

* 주의할 점 

  * 파일 이름과 동일한 이름의 클래스 선언에만 public 접근제한자를 붙일 수 있다

#### 객체 생성과 클래스 변수

* 객체를 생성하는 방법 -> new 연산자를 사용

  Ex) new 클래스();

* new는 클래스로부터 객체를 생성시키는 연산자

* new 연산자로 생성된 객체는 메모리 힙(Heap) 영역에 생성된다

* 클래스 변수 = new 클래스();

#### 클래스의 용도

* 클래스는 두 가지 용도가 있따

  1. 라이브러리(API)

     : 라이브러리 클래스는 다른 클래스에서 이용할 목적을 설계된다

  2. 실행용

     :  실행 클래스는 main() 메소드를 제공하는 역할을 한다

  * 라이브러리인 동시에 실행 클래스도 만들 수 있다 

  #### 클래스의 구성 멤버 

  필드(객체의 데이터가 저장되는 곳), 생성자(객체 생성 시 초기화 열활 담당), 메소드(깩체의 동작에 해당되는 블럭)

  ##### 필드

  : 객체의 **고유** 데이터, **부품** 객체, **상태** 정보(현재 상태)를 저장하는 곳 

  * 초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 초기값으로 설정한다
  * 필드 사용
    * 클래스 내부 : 단순히 필드 이름으로 읽고 변경

  변수 VS 필드

  * 변수는 생성자와 메소드 내에서만 사용, 생성자와 메소드가 실행 종료되면 자동 소멸(위치)
  * 필드는 클래스 내부 전체에서 사용, 객체가 소멸되지 않는 한 객체와 함꼐 존재

##### 생성자 

* 생성자는 new 연산자로 호출되는 특별한 중괄호 {} 블록
* 클래스 이름으로 되어있고 리턴 타입이 없다 

#### 생성자

: new 연산자와 같이 객체를 생성할 때 회출되어 객체의 초기화를 담당한다

* 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 기본 생성자를 바이트 코드에  자동 추가시킨다

[생성자 선언]

* 클래스(매개변수 선언){

  ​	// 객체의 초기화 코드 

  }