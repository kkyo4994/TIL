### import 문

* 다른 패키지에 속하는 클래스를 사용(2가지 방법)

  1. 패키지와 클래스를 모두 기술

     ex) public class Car {

     ​			com.hankook.Tire tire = new com.hankok.Tire();

     }

     * 이 방법이 꼭 필요한 경우 : 서로 다른 패키지에 동일한 클래스 이름이 존재하고 두 패키지가 모두 import되어 있을 경우

  2. import문 사용

     : import문이 작성되는 위치는 패키지 선언과 클래스 사이 선언  사이다

     ex) import com.mycompany*



### Getter와 Setter메소드

* 객체의 무결성이 깨지지 않도록 메소드를 통해 데이터를 변경하는 방법을 선호한다

  (이유 : 메소드는 매개값을 ㄱ머증해서 유효한 값만 데이터로 저장할 수 있기 때문)

ex) 

private 타입 fieldname;

//Getter 

pusblic 리턴 타입 getFieldName(){

​	return fieldName;

}

// Setter

pusblic 리턴 타입 setFieldName(타입 fieldName){

​	this.fieldname =  fieldName;

}



```java
private String sn;

	// Getter
	public String getSn(){

	​	return sn;

	}

	// Setter
	public void setSn(String sn) {
	​	this.sn = sn;

	}
```





### 클래스 상속

* 자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지 결정하고 extends 뒤에 부모 클래스 이름을 기술한다
* 자바는 **다중 상속을 허용하지 않는다** 



### 부모 생성자 호출

* 모든 객체는 클래스의 생성자를 호출해야만 한다. 부모 객체도 예외는 아니다.

* 그렇다면 부모 객체를 생성하기 위해 부모 생성자를 어디서 호출한 것일까?

  * 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다.

  * 명시적으로 선언되지 않았다면, 컴파일러는 다음과 같은 기본 생성자를 생성해 낸다.

    ex) public C() {

    ​	super();

    }

  * 명시적으로 부모 생성자를 호출하는 경우, 만약 매개값의 타입과 일치하는 부모 생성자가 없다면 -> 컴파일 오류가 발생한다

### 메소드 재정의(override)

* 메소드 오버라이딩은 
  * 상속된 메소드의 내용이 자식 클래스에 맞지 않을 경우, 자식 클래스에서 동일한 메소드를 재정의(수정)하는 것을 말한다
* 메소드가 오버라이딩되었다면 부모 객체의 메소드는 숨겨지기 때문에 자식 객체에서 메소드를 호출하면 오버라이딩된 자식 메소드가 호출된다 

#### 메소드를 오버라이딩할 때 규칙

1. 부모의 메소드와 동일한 시그너처(리턴 타입, 메소드 이름, 매개 변수 리스트)를 가져야 한다
2. 접근 제한을 더 강하게 오버라이딩할 수 없다.
3. 새로운 예외를 throws할 수 없다



### final 클래스와 final 메소드

* final 키워드는 클래스, 필드, 메소드 선언 시에 사용할 수 있다..
* final 필드 -> 초기값 설정 후, 더 이상 값을 변경할 수 없다
* final 클래스 -> 부모 클래스가 될 수 없어(상속할 수 없어) 자식 클래스를 만들 수 없다
* final 메소드 -> 오버라이딩할 수 없는 메소드 (부모 클래스에 선언된 final메소드는 자식 클래스에서 재정의할 수 없다)

