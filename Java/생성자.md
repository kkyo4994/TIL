### 생성자

: new 연산자와 같이 객체를 생성할 때 호출되어 객체의 초기화를 담당한다

* 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 기본 생성자를 바이트 코드에 자동 추가시킨다



### 생성자 선언

* 클래스 (매개변수 선언){

  ​	// 객체의 초기화 코드

  }

* 관례적으로 매개변수는 필드와 동일한 이름을 갖도록 한다

  * 생성자 내부에서 필드 접근 불가 -> "this" 사용 

    > this 는 자기 자신을 가르킴

  ```java
  
  public class ClassA {
  	
  	String name;
  	
  	ClassA(String name){
  		name = name;
  	}
  	
  } // 이러면 오류난다
  
  
  public class ClassA {
  	
  	String name;
  	
  	ClassA(String name){
  		this.name = name;
  	}
  	
  } // 일반적인 생상자 사용법
  
  ```

  

### 필드 초기화

* 객체가 생성될 때 필드는 기본 초기값으로 자동 서정된다

* 다른 값으로 초기화 하기 위한 2가지 방법

  1) 필드를 선언할 때 초기값을 주는 방법

  2) 생성자에서 초기값을 주는 방법

* 실제로 

  * 중요한 몇 개 필드만 : 생성자 매개 변수를 통해 초기화
  * 나머지 필드 : 필드 선언 시에 초기화



### 생성자 오버로딩

* 생성자 오버로딩 : 매개 변수를 달리하는 생성자를 여러 개 선언 [ 매개변수 타입, 개수, 순서가 다르게 선언 ]



### 다른 생성자 호출

: 생성자에서 다른 생성자를 호출할 때 this() 코드를 사용한다



### 메소드

: 객체의 동작에 해당하는 중괄호 {} 블록을 말한다



### 메소드 (리턴타입)

* 리턴값이 있느냐 없느냐에 따라 메소드를 호출하는 방법이 조금 다르다

  ex) run(); <-



### 매개변수의 수를 모를 경우

* 경우에 따라서 메소들 선언할 때 매개 변수의 개수를 알 수 없는 경우가 있다

  * 해결책 -> 배열 타입으로 선언

    ex) unt sum(int[] a){}

* 배열의 항목 수는 호출할 때 결정된다

  ex) int x = sum(new int[] {1,2,3});

* 매개 변수를 배열 타입으로 선언하면, 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다

  * 배열을 생성하지 않고 값의 리스트만 넘겨주는 방법도 있다

* 값의 리스트만 넘겨주는 방법

  * 메소드의 매개변수를 "..."를 사용해서 선언

  * 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다

    ex) i메소드 선언 시 -> nt sum(int ... x){}

    ex) 메소드 호출 시 -> sum(1,2,3);

  ```java
  int sum(int ... x){
      int s = 0;
      for(int i=0; i<x.length; i++){
          s += x[i];
      }
      return s;
  }
  ```

  

### 리턴(return)문

* 리컨값이 있는 메소드
  * return문의 리턴값은 리턴 타입이거 리턴 타입으로 변환될 수 있어야 한다. -> byte와 short은 int로 자동 타입 변환
  * return문 이후에 실행문이 오면 컴파일 오류가 발생
  * void 로 선언된 리턴값이 없는 메소드에서도 return문을 사용할 수 있다.

```java
int plus(int x, int y){
    byte result  = (byte)(a)
}
```



### 메소드 호출

* 클래스 내부에서 호출 -> 단순하 메소드 이름으로 호출
* 크래스 외부에서 호출 -> 우선 클래스로부터 객체 생성한 뒤 참조 변수를 이용해 메소드 호출



### 메소드 오버로딩

: 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것 (하나의 메소드 이름으로 여러 기능을 담는다)

* 조건 : 매개변수의 타입, 개수, 순서 중 하나가 달라야 한다
* 오버로딩된 메소드를 호출할 경우 : JVM은 매개값의 타입을 보고, 메소드를 선책한다
* 자바 가상 기계는 일차적으로 매개 변수 타입을 보지만, 매개 변수의 타입이 일치하지 않을 경우 자동 타입 변환이 가능한지를 검사한다



#### 대표적인 예

:System.out.printioj() 메소드 



### 인스턴스 멤버와 this

* 인스턴시 멤버 : 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드 
* 인스턴스 필드와 메소드는 (객체에 소속된 멤버이기 때문에) 객체 없이는 사용할 수 없다. 



### 정적 멤버와 statuc

정적 멤버 : 클래스에 고정된 멤버 (정직->고정된)

* 정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 떄문에 클래스 멤버라고 한다

  ```java
  public class 클래스{
      // 정적 필드
      
  }
  ```

  

  [[필드 선언 ]

  * 인스턴스 필드로 선언할 것인가, 정적 필드로 선언할 것인가 -> 판단 기준

  * [메소드 선언]
    * 인스턴스 메소드로 선언할 것인가, 정적 메소드로 선언할 것인가 -> 판탄기준



* 정적 멤버 사용 -> 클래스 이름과 함께 도트(.) 연산자로 접근

  ex) 클래스.필드;

  ​     클래스.메소드();

* 정적 멤버는 원칙적으로는 클래스 이름으로 접근해야, 하지만 객체 참조 변수로도 접근이 가능

* 정적 멤버는 클래스 이름으로 접근하는 것이 좋다

[정적 초기화 블록]

* 정적 필드는 필드 선언과 동시에 초기값을 주는 것이 보통이다.

* 인스턴스 필드는 생성자에서 초기화하지만, 정적 필드는 생성자에서 초기화 작업을 할 수 없다. 

  -> 자바는 정적 필드의 초기화 작업을 위해 정적 블록을 제공

> 정적 블록은 클래스가 메모리로 로딩될 때 자동적으로 실행된다



### final 필드

: 초기값이 저장 



###  상수 (static final)

: 불변의 값을 저장하는 필드

* 상수는 static이면서 final이어야 한다



### 패키지

: 자바에서 클래스를 체계적으로 관리하기 위해 패키지를 사용한다 (마치 폴더를 만들어 파일 관리하듯이)

* 클래스의 전체 이름은 "패키지명 +  클래스명"이다. (식별자 역할)

  ex) 상위패키지.하위패키지.클래스

* 패키지가 중요한 이유는 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스는 사용할 수 없기 때문(패키지전체를이동시켜야한다)